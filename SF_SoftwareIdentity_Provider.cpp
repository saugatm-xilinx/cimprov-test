// Generated by genprov 2.0.24
#include "SF_SoftwareIdentity_Provider.h"
#include "SF_Sysinfo.h"
#include "CIM_OperatingSystem.h"

CIMPLE_NAMESPACE_BEGIN

using solarflare::System;
using solarflare::SWElement;

SF_SoftwareIdentity *
SF_SoftwareIdentity_Provider::makeReference(const solarflare::SWElement& se)
{
    SF_SoftwareIdentity *identity = SF_SoftwareIdentity::create(true);
    identity->InstanceID.set(System::target.prefix());
    identity->InstanceID.value.append(":");
    identity->InstanceID.value.append(se.name());
    return identity;
}

SF_SoftwareIdentity *
SF_SoftwareIdentity_Provider::swElement(const SWElement& se)
{
    SF_SoftwareIdentity *identity = makeReference(se);
    static const unsigned classmap[] = {
        SF_SoftwareIdentity::_Classifications::enum_Unknown,
        SF_SoftwareIdentity::_Classifications::enum_Unknown,
        SF_SoftwareIdentity::_Classifications::enum_Unknown,
        SF_SoftwareIdentity::_Classifications::enum_Driver,
        SF_SoftwareIdentity::_Classifications::enum_Middleware,
        SF_SoftwareIdentity::_Classifications::enum_Configuration_Software,
        SF_SoftwareIdentity::_Classifications::enum_Software_Bundle,
        SF_SoftwareIdentity::_Classifications::enum_Firmware
    };

    identity->IsEntity.set(true);
    identity->ElementName.set(se.sysName());
    identity->Name.set(se.name());
    identity->MajorVersion.set(se.version().major());
    identity->MinorVersion.set(se.version().minor());
    if (se.version().revision() != solarflare::VersionInfo::unknown)
        identity->RevisionNumber.set(se.version().revision());
    if (se.version().build() != solarflare::VersionInfo::unknown)
    {
        identity->LargeBuildNumber.set(se.version().build());
        identity->IsLargeBuildNumber.set(true);
    }
    identity->VersionString.set(se.version().string());
    identity->ReleaseDate.set(se.version().releaseDate());
    identity->Description.set(se.description());

    identity->Manufacturer.set(System::target.manufacturer());

    identity->IdentityInfoType.null = false;
    identity->IdentityInfoType.value.append("SoftwareID");
    identity->IdentityInfoType.value.append("SoftwareStatus");
    
    identity->IdentityInfoValue.null = false;
    identity->IdentityInfoValue.value.append(se.name());
    identity->IdentityInfoValue.value.append("Default");    

    identity->Classifications.null = false;
    identity->Classifications.value.append(classmap[se.classify()]);
    
    return identity;
}

void SF_SoftwareIdentity_Provider::addTargetOS(SF_SoftwareIdentity *identity)
{
    solarflare::System::OSType type = System::target.osType();
    bool is64 = System::target.is64bit();
    unsigned cimType[][2] = {
        {
            CIM_OperatingSystem::_OSType::enum_Microsoft_Windows_Server_2003, 
            CIM_OperatingSystem::_OSType::enum_Microsoft_Windows_Server_2003_64_Bit
        },
        {
            CIM_OperatingSystem::_OSType::enum_Microsoft_Windows_Server_2008, 
            CIM_OperatingSystem::_OSType::enum_Microsoft_Windows_Server_2008_64_Bit
        },
        {
            CIM_OperatingSystem::_OSType::enum_Microsoft_Windows_Server_2008_R2, 
            CIM_OperatingSystem::_OSType::enum_Microsoft_Windows_Server_2008_R2
        },
        {
            CIM_OperatingSystem::_OSType::enum_RedHat_Enterprise_Linux,
            CIM_OperatingSystem::_OSType::enum_RedHat_Enterprise_Linux_64_Bit
        },
        {
            CIM_OperatingSystem::_OSType::enum_SLES,
            CIM_OperatingSystem::_OSType::enum_SLES_64_Bit
        },
        {
            CIM_OperatingSystem::_OSType::enum_Debian,
            CIM_OperatingSystem::_OSType::enum_Debian_64_Bit
        },
        {
            CIM_OperatingSystem::_OSType::enum_CentOS_32_bit,
            CIM_OperatingSystem::_OSType::enum_CentOS_64_bit
        },
        {
            CIM_OperatingSystem::_OSType::enum_Oracle_Enterprise_Linux_32_bit,
            CIM_OperatingSystem::_OSType::enum_Oracle_Enterprise_Linux_64_bit
        },
        {
            CIM_OperatingSystem::_OSType::enum_Linux_2_6_x,
            CIM_OperatingSystem::_OSType::enum_Linux_2_6_x_64_Bit
        },
        {
            CIM_OperatingSystem::_OSType::enum_VMware_ESXi,
            CIM_OperatingSystem::_OSType::enum_VMware_ESXi,
        }
    };
    identity->TargetOSTypes.null = false;
    identity->TargetOSTypes.value.append(cimType[type][is64]);
}

void SF_SoftwareIdentity_Provider::addPackageType(SF_SoftwareIdentity *identity,
                                                  solarflare::Package::PkgType type)
{
    unsigned pkgType = 0;
    
    using solarflare::Package;
    switch (type)
    {
        case Package::Deb:
            pkgType = SF_SoftwareIdentity::_ExtendedResourceType::enum_Debian_linux_Package;
            break;
        case Package::RPM:
            pkgType = SF_SoftwareIdentity::_ExtendedResourceType::enum_Linux_RPM;
            break;
        case Package::MSI:
            pkgType = SF_SoftwareIdentity::_ExtendedResourceType::enum_Windows_MSI;
            break;
        case Package::VSphereBundle:
            pkgType = SF_SoftwareIdentity::_ExtendedResourceType::enum_VMware_vSphere_Installation_Bundle;
            break;
        case Package::Tarball:
            pkgType = SF_SoftwareIdentity::_ExtendedResourceType::enum_Other;
            identity->OtherExtendedResourceTypeDescription.set("TAR archive");
            break;
        default:
            pkgType = SF_SoftwareIdentity::_ExtendedResourceType::enum_Unknown;
            break;
    }
    if (pkgType != 0)
    {
        identity->ExtendedResourceType.null = false;
        identity->ExtendedResourceType.value = pkgType;
    }
}

SF_SoftwareIdentity *
SF_SoftwareIdentity_Provider::hostSoftware(const SWElement& se)
{
    using namespace solarflare;
    SF_SoftwareIdentity *identity = swElement(se);
    
    addTargetOS(identity);
    if (se.classify() == SWElement::SWPackage)
    {
        addPackageType(identity, static_cast<const Package&>(se).type());
    }

    return identity;
}

SF_SoftwareIdentity_Provider::SF_SoftwareIdentity_Provider()
{
}

SF_SoftwareIdentity_Provider::~SF_SoftwareIdentity_Provider()
{
}

Load_Status SF_SoftwareIdentity_Provider::load()
{
    return LOAD_OK;
}

Unload_Status SF_SoftwareIdentity_Provider::unload()
{
    return UNLOAD_OK;
}

Get_Instance_Status SF_SoftwareIdentity_Provider::get_instance(
    const SF_SoftwareIdentity* model,
    SF_SoftwareIdentity*& instance)
{
    return GET_INSTANCE_UNSUPPORTED;
}

bool SF_SoftwareIdentity_Provider::SWEnum::process(const solarflare::SWElement& se)
{
    SF_SoftwareIdentity *identity = NULL;

    identity = hostSoftware(se);
    handler->handle(identity);

    return true;
}

Enum_Instances_Status SF_SoftwareIdentity_Provider::enum_instances(
    const SF_SoftwareIdentity* model,
    Enum_Instances_Handler<SF_SoftwareIdentity>* handler)
{
    using namespace solarflare;
    SWEnum instances(handler);
    

    CIMPLE_DBG(("enumerating objects"));
    System::target.forAllSoftware(instances);

    return ENUM_INSTANCES_OK;
}

Create_Instance_Status SF_SoftwareIdentity_Provider::create_instance(
    SF_SoftwareIdentity* instance)
{
    return CREATE_INSTANCE_UNSUPPORTED;
}

Delete_Instance_Status SF_SoftwareIdentity_Provider::delete_instance(
    const SF_SoftwareIdentity* instance)
{
    return DELETE_INSTANCE_UNSUPPORTED;
}

Modify_Instance_Status SF_SoftwareIdentity_Provider::modify_instance(
    const SF_SoftwareIdentity* model,
    const SF_SoftwareIdentity* instance)
{
    return MODIFY_INSTANCE_UNSUPPORTED;
}

/*@END@*/

CIMPLE_NAMESPACE_END
