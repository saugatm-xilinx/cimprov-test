/***************************************************************************//*! \file liprovider/SF_NICCard_Provider.cpp
** <L5_PRIVATE L5_SOURCE>
** \author  OktetLabs
**  \brief  CIM Provider
**   \date  2013/10/02
**    \cop  (c) Solarflare Communications Inc.
** </L5_PRIVATE>
*//*
\**************************************************************************/

// Generated by genprov 2.0.24
#include "SF_NICCard_Provider.h"
#include "sf_provider.h"
#include "sf_logging.h"
#include "sf_platform.h"

CIMPLE_NAMESPACE_BEGIN

enum ReturnValue 
{
    OK = 0,
    Error = 2,
    InvalidParameter = 5,
};


SF_NICCard_Provider::SF_NICCard_Provider()
{
}

SF_NICCard_Provider::~SF_NICCard_Provider()
{
}

Load_Status SF_NICCard_Provider::load()
{
    solarflare::CIMHelper::initialize();
    return LOAD_OK;
}

Unload_Status SF_NICCard_Provider::unload()
{
    return UNLOAD_OK;
}

Get_Instance_Status SF_NICCard_Provider::get_instance(
    const SF_NICCard* model,
    SF_NICCard*& instance)
{
    return GET_INSTANCE_UNSUPPORTED;
}

Enum_Instances_Status SF_NICCard_Provider::enum_instances(
    const SF_NICCard* model,
    Enum_Instances_Handler<SF_NICCard>* handler)
{
    solarflare::EnumInstances<SF_NICCard>::allNICs(handler);
    return ENUM_INSTANCES_OK;
}

Create_Instance_Status SF_NICCard_Provider::create_instance(
    SF_NICCard* instance)
{
    return CREATE_INSTANCE_UNSUPPORTED;
}

Delete_Instance_Status SF_NICCard_Provider::delete_instance(
    const SF_NICCard* instance)
{
    return DELETE_INSTANCE_UNSUPPORTED;
}

Modify_Instance_Status SF_NICCard_Provider::modify_instance(
    const SF_NICCard* model,
    const SF_NICCard* instance)
{
    return MODIFY_INSTANCE_UNSUPPORTED;
}

Invoke_Method_Status SF_NICCard_Provider::IsCompatible(
    const SF_NICCard* self,
    const CIM_PhysicalElement* ElementToCheck,
    Property<uint32>& return_value)
{
    return INVOKE_METHOD_UNSUPPORTED;
}

Invoke_Method_Status SF_NICCard_Provider::ConnectorPower(
    const SF_NICCard* self,
    const CIM_PhysicalConnector* Connector,
    const Property<boolean>& PoweredOn,
    Property<uint32>& return_value)
{
    return INVOKE_METHOD_UNSUPPORTED;
}

#ifdef TARGET_CIM_SERVER_esxi
using solarflare::VPDField;

class VPDGetter : public solarflare::ActionForAll
{
    bool ok;
    bool NICFound;
    bool staticVPD;
    Array<VPDField> parsedFields;
protected:
    virtual void handler(solarflare::SystemElement& se, unsigned);
public:
    VPDGetter(const Instance *inst, bool getStaticVPD) :
      solarflare::ActionForAll(inst), ok(false),
      NICFound(false), staticVPD(getStaticVPD) {}
    Array<VPDField> &getParsedFields() { return parsedFields; }
    bool isOK() const { return ok; }
    bool isNICFound() const { return NICFound; }
};

void VPDGetter::handler(solarflare::SystemElement& se, unsigned)
{
    int rc;

    solarflare::NIC& nic = static_cast<solarflare::NIC&>(se);

    NICFound = true;

    if (ok)
    {
        PROVIDER_LOG_ERR("%s(): trying to get VPD from "
                         "more than one NIC at once", __FUNCTION__);
        return;
    }

    rc = nic.getFullVPD(staticVPD, parsedFields);
    if (rc >= 0)
        ok = true;
}

Invoke_Method_Status SF_NICCard_Provider::GetVPDFields(
    const SF_NICCard* self,
    const Property<boolean>& StaticVPD,
    Property<Array_String>& FieldNames,
    Property<Array_String>& FieldValues,
    Property<Array_boolean>& HexValues,
    Property<uint32>& return_value)
{
    bool staticVPD = true;

    if (!StaticVPD.null)
        staticVPD = StaticVPD.value;

    VPDGetter vpdGetter(cast<Instance *>(self), staticVPD);

    vpdGetter.forNIC();
    if (vpdGetter.isOK())
    {
        unsigned int i;
        unsigned int j;
        bool         isHex;

        FieldNames.null = false;
        FieldValues.null = false;
        HexValues.null = false;

        for (i = 0; i < vpdGetter.getParsedFields().size(); i++)
        {
            VPDField &field = vpdGetter.getParsedFields()[i];

            FieldNames.value.append(field.name);

            isHex = false;
            if (strcmp(field.name.c_str(), "RV") == 0 ||
                strcmp(field.name.c_str(), "CP") == 0)
                isHex = true;
            else
            {
                for (j = 0; j < field.data.size(); j++)
                {
                    if (!(field.data[j] >= 32 && field.data[j] <= 126))
                    {
                        isHex = true;
                        break;
                    }
                }
            }

            if (isHex)
            {
                Buffer hexValue;

                for (j = 0; j < field.data.size(); j++)
                    hexValue.format("%.2x",
                                    static_cast<int>(field.data[j]));

                HexValues.value.append(true);
                FieldValues.value.append(String(hexValue.data()));
            }
            else
            {
                HexValues.value.append(false);
                FieldValues.value.append(String(field.data.data()));
            }
        }

        return_value.set(OK);
    }
    else
    {
        if (!vpdGetter.isNICFound())
            PROVIDER_LOG_ERR("%s(): failed to find NIC", __FUNCTION__);
        return_value.set(Error);
    }

    return INVOKE_METHOD_OK;
}

#endif

/*@END@*/

CIMPLE_NAMESPACE_END
